{"version":3,"file":"tooltip.js.map","sources":["../src/popper/utils/isFunction.js","../src/tooltip/index.js"],"sourcesContent":["/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === '[object Function]'\n  );\n}\n","import Popper from 'popper.js';\nimport isFunction from '../popper/utils/isFunction';\n\nconst DEFAULT_OPTIONS = {\n  container: false,\n  delay: 0,\n  html: false,\n  placement: 'top',\n  title: '',\n  template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  offset: 0,\n};\n\nexport default class Tooltip {\n  /**\n   * Create a new Tooltip.js instance\n   * @class Tooltip\n   * @param {HTMLElement} reference - The reference element used to position the tooltip\n   * @param {Object} options\n   * @param {String} options.placement=bottom\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n   *      left(-start, -end)`\n   *\n   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).\n   * @param {Object} options - Configuration of the tooltip\n   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.\n   * @param {Number|Object} options.delay=0\n   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.\n   *      If a number is supplied, delay is applied to both hide/show.\n   *      Object structure is: `{ show: 500, hide: 100 }`\n   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.\n   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.\n   * @param {String} options.template='<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>'\n   *      Base HTML to used when creating the tooltip.\n   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.\n   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.\n   *      The outermost wrapper element should have the `.tooltip` class.\n   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.\n   * @param {String} options.trigger='hover focus'\n   *      How tooltip is triggered - click | hover | focus | manual.\n   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.\n   * @param {HTMLElement} options.boundariesElement\n   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'\n   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)\n   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'\n   *      [offset docs](https://popper.js.org/popper-documentation.html)\n   * @return {Object} instance - The generated tooltip instance\n   */\n  constructor(reference, options) {\n    // apply user options over default ones\n    options = { ...DEFAULT_OPTIONS, ...options };\n\n    reference.jquery && (reference = reference[0]);\n\n    // cache reference and options\n    this.reference = reference;\n    this.options = options;\n\n    // get events list\n    const events = typeof options.trigger === 'string'\n      ? options.trigger\n          .split(' ')\n          .filter(\n            trigger => ['click', 'hover', 'focus'].indexOf(trigger) !== -1\n          )\n      : [];\n\n    // set initial state\n    this._isOpen = false;\n\n    // set event listeners\n    this._setEventListeners(reference, events, options);\n  }\n\n  //\n  // Public methods\n  //\n\n  /**\n   * Reveals an element's tooltip. This is considered a \"manual\" triggering of the tooltip.\n   * Tooltips with zero-length titles are never displayed.\n   * @memberof Tooltip\n   */\n  show = () => this._show(this.reference, this.options);\n\n  /**\n   * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @memberof Tooltip\n   */\n  hide = () => this._hide();\n\n  /**\n   * Hides and destroys an element’s tooltip.\n   * @memberof Tooltip\n   */\n  dispose = () => this._dispose();\n\n  /**\n   * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * @memberof Tooltip\n   */\n  toggle = () => {\n    if (this._isOpen) {\n      return this.hide();\n    } else {\n      return this.show();\n    }\n  };\n\n  //\n  // Defaults\n  //\n  arrowSelector = '.tooltip-arrow, .tooltip__arrow';\n  innerSelector = '.tooltip-inner, .tooltip__inner';\n\n  //\n  // Private methods\n  //\n\n  _events = [];\n\n  /**\n   * Creates a new tooltip node\n   * @memberof Tooltip\n   * @private\n   * @param {HTMLElement} reference\n   * @param {String} template\n   * @param {String|HTMLElement|TitleFunction} title\n   * @param {Boolean} allowHtml\n   * @return {HTMLelement} tooltipNode\n   */\n  _create(reference, template, title, allowHtml) {\n    // create tooltip element\n    const tooltipGenerator = window.document.createElement('div');\n    tooltipGenerator.innerHTML = template.trim();\n    const tooltipNode = tooltipGenerator.childNodes[0];\n\n    // add unique ID to our tooltip (needed for accessibility reasons)\n    tooltipNode.id = `tooltip_${Math.random().toString(36).substr(2, 10)}`;\n\n    // set initial `aria-hidden` state to `false` (it's visible!)\n    tooltipNode.setAttribute('aria-hidden', 'false');\n\n    // add title to tooltip\n    const titleNode = tooltipGenerator.querySelector(this.innerSelector);\n    if (title.nodeType === 1) {\n      // if title is a node, append it only if allowHtml is true\n      allowHtml && titleNode.appendChild(title);\n    } else if (isFunction(title)) {\n      // if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value\n      const titleText = title.call(reference);\n      allowHtml\n        ? (titleNode.innerHTML = titleText)\n        : (titleNode.innerText = titleText);\n    } else {\n      // if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value\n      allowHtml ? (titleNode.innerHTML = title) : (titleNode.innerText = title);\n    }\n\n    // return the generated tooltip node\n    return tooltipNode;\n  }\n\n  _show(reference, options) {\n    // don't show if it's already visible\n    if (this._isOpen) {\n      return this;\n    }\n    this._isOpen = true;\n\n    // if the tooltipNode already exists, just show it\n    if (this._tooltipNode) {\n      this._tooltipNode.style.display = '';\n      this._tooltipNode.setAttribute('aria-hidden', 'false');\n      this.popperInstance.update();\n      return this;\n    }\n\n    // get title\n    const title = reference.getAttribute('title') || options.title;\n\n    // don't show tooltip if no title is defined\n    if (!title) {\n      return this;\n    }\n\n    // create tooltip node\n    const tooltipNode = this._create(\n      reference,\n      options.template,\n      title,\n      options.html\n    );\n\n    // Add `aria-describedby` to our reference element for accessibility reasons\n    tooltipNode.setAttribute('aria-describedby', tooltipNode.id);\n\n    // append tooltip to container\n    const container = this._findContainer(options.container, reference);\n\n    this._append(tooltipNode, container);\n\n    const popperOptions = {\n      placement: options.placement,\n      modifiers: {\n        arrow: {\n          element: this.arrowSelector,\n        },\n      },\n    };\n\n    if (options.boundariesElement) {\n      popperOptions.modifiers.preventOverflow = {\n        boundariesElement: options.boundariesElement,\n      };\n    }\n\n    this.popperInstance = new Popper(reference, tooltipNode, popperOptions);\n\n    this._tooltipNode = tooltipNode;\n\n    return this;\n  }\n\n  _hide(/*reference, options*/) {\n    // don't hide if it's already hidden\n    if (!this._isOpen) {\n      return this;\n    }\n\n    this._isOpen = false;\n\n    // hide tooltipNode\n    this._tooltipNode.style.display = 'none';\n    this._tooltipNode.setAttribute('aria-hidden', 'true');\n\n    return this;\n  }\n\n  _dispose() {\n    if (this._tooltipNode) {\n      this._hide();\n\n      // destroy instance\n      this.popperInstance.destroy();\n\n      // remove event listeners\n      this._events.forEach(({ func, event }) => {\n        this.reference.removeEventListener(event, func);\n      });\n      this._events = [];\n\n      // destroy tooltipNode\n      this._tooltipNode.parentNode.removeChild(this._tooltipNode);\n      this._tooltipNode = null;\n    }\n    return this;\n  }\n\n  _findContainer(container, reference) {\n    // if container is a query, get the relative element\n    if (typeof container === 'string') {\n      container = window.document.querySelector(container);\n    } else if (container === false) {\n      // if container is `false`, set it to reference parent\n      container = reference.parentNode;\n    }\n    return container;\n  }\n\n  /**\n   * Append tooltip to container\n   * @memberof Tooltip\n   * @private\n   * @param {HTMLElement} tooltip\n   * @param {HTMLElement|String|false} container\n   */\n  _append(tooltipNode, container) {\n    container.appendChild(tooltipNode);\n  }\n\n  _setEventListeners(reference, events, options) {\n    const directEvents = [];\n    const oppositeEvents = [];\n\n    events.forEach(event => {\n      switch (event) {\n        case 'hover':\n          directEvents.push('mouseenter');\n          oppositeEvents.push('mouseleave');\n        case 'focus':\n          directEvents.push('focus');\n          oppositeEvents.push('blur');\n        case 'click':\n          directEvents.push('click');\n          oppositeEvents.push('click');\n      }\n    });\n\n    // schedule show tooltip\n    directEvents.forEach(event => {\n      const func = evt => {\n        if (this._isOpen === true) {\n          return;\n        }\n        evt.usedByTooltip = true;\n        this._scheduleShow(reference, options.delay, options, evt);\n      };\n      this._events.push({ event, func });\n      reference.addEventListener(event, func);\n    });\n\n    // schedule hide tooltip\n    oppositeEvents.forEach(event => {\n      const func = evt => {\n        if (evt.usedByTooltip === true) {\n          return;\n        }\n        this._scheduleHide(reference, options.delay, options, evt);\n      };\n      this._events.push({ event, func });\n      reference.addEventListener(event, func);\n    });\n  }\n\n  _scheduleShow(reference, delay, options /*, evt */) {\n    // defaults to 0\n    const computedDelay = (delay && delay.show) || delay || 0;\n    window.setTimeout(() => this._show(reference, options), computedDelay);\n  }\n\n  _scheduleHide(reference, delay, options, evt) {\n    // defaults to 0\n    const computedDelay = (delay && delay.hide) || delay || 0;\n    window.setTimeout(() => {\n      if (this._isOpen === false) {\n        return;\n      }\n      if (!document.body.contains(this._tooltipNode)) {\n        return;\n      }\n\n      // if we are hiding because of a mouseleave, we must check that the new\n      // reference isn't the tooltip, because in this case we don't want to hide it\n      if (evt.type === 'mouseleave') {\n        const isSet = this._setTooltipNodeEvent(evt, reference, delay, options);\n\n        // if we set the new event, don't hide the tooltip yet\n        // the new event will take care to hide it if necessary\n        if (isSet) {\n          return;\n        }\n      }\n\n      this._hide(reference, options);\n    }, computedDelay);\n  }\n\n  _setTooltipNodeEvent = (evt, reference, delay, options) => {\n    const relatedreference = evt.relatedreference || evt.toElement;\n\n    const callback = evt2 => {\n      const relatedreference2 = evt2.relatedreference || evt2.toElement;\n\n      // Remove event listener after call\n      this._tooltipNode.removeEventListener(evt.type, callback);\n\n      // If the new reference is not the reference element\n      if (!reference.contains(relatedreference2)) {\n        // Schedule to hide tooltip\n        this._scheduleHide(reference, options.delay, options, evt2);\n      }\n    };\n\n    if (this._tooltipNode.contains(relatedreference)) {\n      // listen to mouseleave on the tooltip element to be able to hide the tooltip\n      this._tooltipNode.addEventListener(evt.type, callback);\n      return true;\n    }\n\n    return false;\n  };\n}\n\n/**\n * Placement function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback PlacementFunction\n * @param {HTMLElement} tooltip - tooltip DOM node.\n * @param {HTMLElement} reference - reference DOM node.\n * @return {String} placement - One of the allowed placement options.\n */\n\n/**\n * Title function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback TitleFunction\n * @return {String} placement - The desired title.\n */\n"],"names":["isFunction","functionToCheck","getType","toString","call","DEFAULT_OPTIONS","Tooltip","reference","options","jquery","events","trigger","split","filter","indexOf","_isOpen","_setEventListeners","template","title","allowHtml","tooltipGenerator","window","document","createElement","innerHTML","trim","tooltipNode","childNodes","id","Math","random","substr","setAttribute","titleNode","querySelector","innerSelector","nodeType","appendChild","titleText","innerText","_tooltipNode","style","display","popperInstance","update","getAttribute","_create","html","container","_findContainer","_append","popperOptions","placement","arrowSelector","boundariesElement","modifiers","preventOverflow","Popper","_hide","destroy","_events","forEach","func","event","removeEventListener","parentNode","removeChild","directEvents","oppositeEvents","push","evt","usedByTooltip","_scheduleShow","delay","addEventListener","_scheduleHide","computedDelay","show","setTimeout","_show","hide","body","contains","type","isSet","_setTooltipNodeEvent","dispose","_dispose","toggle","relatedreference","toElement","callback","evt2","relatedreference2"],"mappings":"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"}